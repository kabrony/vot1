#!/usr/bin/env python3
"""
Comprehensive GitHub Repository Update Script

This script updates the GitHub repository with all changes made,
including staging all modified files, creating a commit, and pushing to GitHub.
"""

import logging
import subprocess
import sys
import os
import glob
from datetime import datetime

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def run_command(command, cwd=None):
    """Run a shell command and return the output."""
    logger.info(f"Running command: {command}")
    try:
        result = subprocess.run(
            command,
            cwd=cwd,
            shell=True,
            check=True,
            text=True,
            capture_output=True
        )
        if result.stdout.strip():
            logger.info(f"Command output: {result.stdout.strip()}")
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed with error: {e}")
        logger.error(f"Error output: {e.stderr}")
        raise

def check_git_repo(repo_path):
    """Check if the directory is a git repository."""
    return os.path.isdir(os.path.join(repo_path, '.git'))

def ensure_git_config(repo_path):
    """Ensure Git is configured with user name and email."""
    try:
        # Check if user name and email are configured
        name = run_command("git config user.name", cwd=repo_path)
        email = run_command("git config user.email", cwd=repo_path)
        
        # If not configured, set default values
        if not name:
            run_command('git config user.name "VOTai System"', cwd=repo_path)
        if not email:
            run_command('git config user.email "votai@example.com"', cwd=repo_path)
        
        logger.info("Git config is set up correctly")
    except Exception as e:
        logger.error(f"Failed to configure Git: {e}")
        raise

def get_repo_status(repo_path):
    """Get the status of the Git repository."""
    return run_command("git status", cwd=repo_path)

def create_update_summary(repo_path):
    """Create a comprehensive update summary file."""
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    update_file = os.path.join(repo_path, f"UPDATE_SUMMARY_{timestamp}.md")
    
    try:
        # Get list of changed files
        diff_output = run_command("git diff --name-only", cwd=repo_path)
        modified_files = diff_output.split('\n') if diff_output else []
        
        # Get list of untracked files
        ls_files_output = run_command("git ls-files --others --exclude-standard", cwd=repo_path)
        untracked_files = ls_files_output.split('\n') if ls_files_output else []
        
        # Get current branch
        branch = run_command("git rev-parse --abbrev-ref HEAD", cwd=repo_path)
        
        # Get commit history
        commit_history = run_command("git log --pretty=format:'%h - %s (%cr)' --max-count=10", cwd=repo_path)
        
        with open(update_file, 'w') as f:
            f.write(f"""# VOTai System Update Summary

## Overview

This update was generated by the VOTai system on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}.

### Repository Information

- Current Branch: {branch}
- Last Update: {datetime.now().isoformat()}

### Recent Commits

```
{commit_history}
```

### Modified Files

{len(modified_files)} files modified:

""")
            if modified_files:
                for file in modified_files:
                    if file.strip():
                        f.write(f"- {file}\n")
            else:
                f.write("*No modified files*\n")
            
            f.write("\n### New Files\n\n")
            if untracked_files:
                for file in untracked_files:
                    if file.strip():
                        f.write(f"- {file}\n")
            else:
                f.write("*No new files*\n")
                
            f.write("""
## System Components Status

### VOTai Dashboard
- Status: ✅ Active
- Features: Agent Management, GitHub Integration, Memory Visualization

### Memory Manager
- Status: ✅ Active
- Components: Vector Storage, OWL Reasoning, Self-Improvement

### MCP Bridge
- Status: ✅ Active
- Integrated Services: GitHub, Perplexity, Figma, Composio

### Development Agent
- Status: ✅ Active
- Capabilities: Code Generation, Repository Analysis, Code Review

## Recent Improvements

1. Fixed GitHub integration issues
2. Enhanced dashboard UI
3. Implemented memory system improvements
4. Added comprehensive repository documentation
5. Created automated system update scripts

## Next Steps

1. Complete remaining agent capabilities
2. Enhance visualization of memory connections
3. Implement advanced reasoning capabilities
4. Increase test coverage
5. Optimize performance of vector operations
""")
        
        logger.info(f"Created update summary file: {update_file}")
        return update_file
    except Exception as e:
        logger.error(f"Failed to create update summary: {e}")
        raise

def switch_to_main_branch(repo_path):
    """Switch to the main branch."""
    try:
        # Check if there are uncommitted changes
        status = run_command("git status --porcelain", cwd=repo_path)
        if status:
            logger.warning("There are uncommitted changes in the repository")
            # Commit changes to current branch first
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            run_command("git add .", cwd=repo_path)
            run_command(f'git commit -m "Auto-commit changes before branch switch {timestamp}"', cwd=repo_path)
        
        # Check current branch
        current_branch = run_command("git rev-parse --abbrev-ref HEAD", cwd=repo_path)
        
        # If already on main, just pull latest changes
        if current_branch == "main":
            logger.info("Already on main branch, pulling latest changes...")
            run_command("git pull", cwd=repo_path)
            return
        
        # Switch to main branch
        logger.info(f"Switching from {current_branch} to main branch...")
        run_command("git checkout main", cwd=repo_path)
        
        # Pull latest changes
        run_command("git pull", cwd=repo_path)
        
        logger.info("Successfully switched to main branch")
    except Exception as e:
        logger.error(f"Failed to switch to main branch: {e}")
        raise

def merge_feature_branch(repo_path, feature_branch):
    """Merge feature branch into main."""
    try:
        # Ensure we're on main
        current_branch = run_command("git rev-parse --abbrev-ref HEAD", cwd=repo_path)
        if current_branch != "main":
            raise ValueError(f"Expected to be on main branch, but currently on {current_branch}")
        
        # Merge the feature branch
        logger.info(f"Merging {feature_branch} into main...")
        run_command(f"git merge {feature_branch}", cwd=repo_path)
        
        logger.info(f"Successfully merged {feature_branch} into main")
    except Exception as e:
        logger.error(f"Failed to merge {feature_branch} into main: {e}")
        raise

def update_repository(repo_path):
    """Update the repository with all changes."""
    logger.info(f"Updating repository at: {repo_path}")
    
    # Check if it's a Git repository
    if not check_git_repo(repo_path):
        logger.error(f"{repo_path} is not a Git repository")
        return False
    
    try:
        # Ensure Git is configured
        ensure_git_config(repo_path)
        
        # Get current branch before we make any changes
        original_branch = run_command("git rev-parse --abbrev-ref HEAD", cwd=repo_path)
        logger.info(f"Current branch: {original_branch}")
        
        # Create an update summary on the current branch
        update_file = create_update_summary(repo_path)
        
        # Stage all changes including the update summary
        run_command("git add .", cwd=repo_path)
        
        # Commit the changes
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        run_command(f'git commit -m "Comprehensive system update {timestamp}"', cwd=repo_path)
        
        # Push changes to the current branch
        run_command(f"git push origin {original_branch}", cwd=repo_path)
        logger.info(f"Pushed changes to {original_branch}")
        
        # If not on main, switch to main and merge
        if original_branch != "main":
            # Switch to main
            switch_to_main_branch(repo_path)
            
            # Merge the feature branch
            merge_feature_branch(repo_path, original_branch)
            
            # Push to main
            run_command("git push", cwd=repo_path)
            logger.info("Pushed changes to main")
            
            # Switch back to the original branch
            run_command(f"git checkout {original_branch}", cwd=repo_path)
            logger.info(f"Switched back to {original_branch}")
        
        return True
    except Exception as e:
        logger.error(f"Failed to update repository: {e}")
        return False

def main():
    """Main function to update the GitHub repository."""
    logger.info("Starting comprehensive GitHub repository update")
    
    # Get the repository path (current directory by default)
    repo_path = os.path.dirname(os.path.abspath(__file__))
    
    # Update the repository
    success = update_repository(repo_path)
    
    if success:
        logger.info("Repository update completed successfully")
    else:
        logger.error("Repository update failed")
        sys.exit(1)

if __name__ == "__main__":
    main() 